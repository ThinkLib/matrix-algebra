fmod MA is
    protecting INT .
    protecting BOOL .
    protecting TRUTH-VALUE .
    protecting QID .
    sorts MatrixExpr MatrixSymbol . 
    subsort MatrixSymbol < MatrixExpr . 

    vars A B C X Y : MatrixExpr .
    var S : MatrixSymbol .
    vars a b n m : Int .
    var M : Qid .

    *** MATRIX OPERATIONS
    ops I Z : -> MatrixSymbol .
    op matrix : Qid Pair -> MatrixSymbol .
    op _+_ : MatrixExpr MatrixExpr -> MatrixExpr [ctor assoc comm prec 30] .
    op __ : MatrixExpr MatrixExpr -> MatrixExpr [ctor prec 25] .
    op transpose : MatrixExpr -> MatrixExpr [ctor] .
    op inverse : MatrixExpr -> MatrixExpr [ctor] .

    eq A (B + C) = (A B) + (A C) [metadata "Distributive Law"] . 
    eq Z + A = A . 
    eq I A = A .
    eq A I = A .

    eq transpose(transpose(A)) = A .
    *** eq transpose(A B) = transpose(B) transpose(A) .
    *** eq transpose(A + B) = transpose(A) + transpose(B) .

    eq inverse(inverse(A)) = A .
    eq inverse(A + B) = inverse(A) + inverse(B) .
    eq inverse(A) A = I .
    eq A inverse(A) = I .
    
    *** SHAPE
    sort Pair . 
    op _by_ : Int Int -> Pair .
    op _==_ : Pair Pair -> Bool .
    op first : Pair -> Int .
    op second : Pair -> Int .
    eq first( n by m ) = n . 
    eq second( n by m ) = m .
    vars P1 P2 : Pair .
    eq (P1 == P2) = (first(P1) == first(P2)) and (second(P1) == second(P2)) .

    op shape : MatrixExpr -> Pair .
    op rows : MatrixExpr -> Int .
    op cols : MatrixExpr -> Int .
    eq rows(A) = first(shape(A)) . 
    eq cols(A) = second(shape(A)) . 

    op is_square : MatrixExpr -> Bool . 
    eq is_square(X) = rows(X) == cols(X) .

    eq shape(matrix(M, n by m)) = n by m . 
    eq shape(A B) = rows(A) by cols(B) .
    eq shape(A + B) = shape(A) .
    eq shape(transpose(A)) = cols(A) by rows(A) .
    eq shape(inverse(A)) = shape(A) .

    op valid : MatrixExpr -> Bool .
    eq valid(S) = true . *** all symbols are valid
    eq valid(X Y) = valid(X) and valid(Y) and (cols(X) == rows(Y)) .
    eq valid(X + Y) = valid(X) and valid(Y) and (shape(X) == shape(Y)) .
    eq valid(transpose(X)) = valid(X) .
    eq valid(inverse(X)) = valid(X) and is_square(X) . 

endfm

fmod MAT-TEST is  
    protecting MA .  
    ops X Y : -> MatrixSymbol .
    ops n m k l p : -> Int .
    eq X = matrix('X, n by m) .
    eq Y = matrix('Y, m by n) .
    op mat1 : -> MatrixExpr .

    eq mat1 = transpose(Y transpose(X Y)) .
endfm 

*** ==========================================================================

fmod MA-ASSUMPTIONS is 
    protecting MA .
    sort Predicate .
    sort AppliedPredicate .
    sort Context .
    subsort AppliedPredicate < Context .

    op empty : -> Context [ctor] .  
    op _,_ : Context Context -> Context  
            [ctor assoc comm id: empty prec 49 format (d r os d)] .

    ops symmetric orthogonal invertible : -> Predicate .
    ops positive-definite singular : -> Predicate .
    ops lower-triangular upper-triangular diagonal tridiagonal : -> Predicate .

    op _is_ : MatrixExpr Predicate -> AppliedPredicate [prec 45].

    var AP : AppliedPredicate . 
    var C : Context .
    vars X Y : MatrixExpr .

    *** IMPLICATION
    op _=>_ : Context AppliedPredicate -> Bool [prec 50] . *** Implies
    op _<=_ : AppliedPredicate Context -> Bool [prec 50] .
    op _in_ : AppliedPredicate Context -> Bool [prec 50] .
    eq AP <= C = C => AP .

    ceq C => AP = true if AP in C .

    *** SYMMETRIC
    ceq C => X Y is symmetric   = true if C => X is symmetric
                                      and C => Y is symmetric .
    ceq C => X + Y is symmetric = true if C => X is symmetric 
                                      and C => Y is symmetric .
    ceq C => transpose(X) is symmetric = true if C => X is symmetric .
    eq C => transpose(X) X is symmetric = true .
    eq C => X transpose(X) is symmetric = true .
    ceq C => X Y transpose(X) is symmetric = true if C => Y is symmetric .
    ceq C => transpose(X) Y X is symmetric = true if C => Y is symmetric .

    *** ORTHOGONAL
    ceq C => X Y is orthogonal = true if C => X is orthogonal
                                    and  C => Y is orthogonal .
    ceq C => X is invertible = true if C => X is orthogonal .
    ceq C => transpose(X) is orthogonal = true if C => X is orthogonal .
    ceq C => inverse(X)   is orthogonal = true if C => X is orthogonal .

    *** POSITIVE DEFINITE 
    ceq C => X Y is positive-definite = true 
                    if C => X is positive-definite 
                   and C => Y is positive-definite .     
    ceq C => X + Y is positive-definite = true
                    if C => X is positive-definite 
                   and C => Y is positive-definite .     
    ceq C => X is positive-definite = true if C => X is orthogonal .
    ceq C => X is invertible = true if C => X is positive-definite .

    *** SINGULAR
    ceq C => X is positive-definite = false if C => X is singular == true .
    ceq C => X is invertible = false if C => X is singular .

    *** TRIANGULAR, DIAGONAL
    ceq C => X Y is lower-triangular   = true if C => X is lower-triangular 
                                            and  C => Y is lower-triangular .
    ceq C => X Y is upper-triangular   = true if C => X is upper-triangular 
                                            and  C => Y is upper-triangular .
    ceq C => X + Y is lower-triangular = true if C => X is lower-triangular 
                                            and  C => Y is lower-triangular .
    ceq C => X + Y is upper-triangular = true if C => X is upper-triangular 
                                            and  C => Y is upper-triangular .
    ceq C => X + Y is diagonal = true if C => X is diagonal 
                                     and C => Y is diagonal .
    ceq C => X Y is diagonal   = true if C => X is diagonal 
                                     and C => Y is diagonal .


    *** Catch all - ask for direct membership in the context 
    eq C => AP = AP in C .

    eq AP in (AP, C) = true .
    eq AP in C = false [owise] .

endfm

fmod MA-ASSUMPTIONS-TEST is  
    protecting MA-ASSUMPTIONS .  
    ops X Y : -> MatrixSymbol .
    ops n m k l p : -> Int .
    eq X = matrix('X, n by m) .
    eq Y = matrix('Y, m by n) .

    ops ctxt ctxt2 ctxt3 : -> Context .
    ops query query2 query3 : -> Context .
    eq query = X is symmetric . 
    eq query2 = Y is symmetric .
    eq query3 = X Y is symmetric .
    eq ctxt = X is symmetric , X is orthogonal , Y is symmetric .
    eq ctxt2 = X Y is symmetric , X is orthogonal .
    eq ctxt3 = X Z is symmetric , Y is symmetric .
endfm 

*** ======================================================================= ***

fmod MA-SIMPLIFY is 
    protecting MA .  
    protecting MA-ASSUMPTIONS .  
    protecting TRUTH-VALUE .

    sort Situation .
    op _with_ : MatrixExpr Context -> Situation .
    op simplify : Situation -> Situation .
    op matrixof : Situation -> MatrixExpr .

    vars X Y : MatrixExpr .
    var S : MatrixSymbol .
    var C : Context .

    *** We can treat situtions like MatrixExprs
    op __ : Situation Situation -> Situation .
    eq (X with C) (Y with C) = X Y with C .
    op _+_ : Situation Situation -> Situation .
    eq (X with C) + (Y with C) = X + Y with C .
    op transpose : Situation -> Situation .
    eq transpose(X with C) = transpose(X) with C .
    op inverse : Situation -> Situation .
    eq inverse(X with C) = inverse(X) with C .

    *** TRANSPOSES
    eq simplify(S with C) = S with C .
    ceq simplify(X transpose(X) with C) = I with C
        if C => X is orthogonal .
    ceq simplify(transpose(X) with C) = simplify(X with C) 
        if C => X is symmetric .

    *** INVERSES
    ceq simplify(inverse(X) with C) = simplify(transpose(X) with C)
                                if C => X is orthogonal .

    *** Catch Alls, reduce simplify to sub-terms
    *** TODO these are currently ambiguous
    eq simplify(X Y with C) = simplify(X with C) simplify(Y with C) [owise] .
    eq simplify(X + Y with C) = simplify(X with C) + simplify(Y with C) [owise].
    eq simplify(transpose(X) with C) = transpose(simplify(X with C)) [owise] .
    eq simplify(inverse(X) with C) = inverse(simplify(X with C)) [owise] .

    eq matrixof(X with C) = X .

endfm 

fmod MA-SIMPLIFY-TEST is  
    protecting MA-SIMPLIFY .  
    ops X Y Z : -> MatrixSymbol .
    ops n m k l p : -> Int .
    eq X = matrix('X, n by m) .
    eq Y = matrix('Y, m by n) .

    ops ctxt ctxt2 ctxt3 : -> Context .
    ops query query2 : -> Context .
    eq query = X is symmetric . 
    eq query2 = Y is symmetric .
    eq ctxt = X is symmetric , X is orthogonal , Y is symmetric .
    eq ctxt2 = X Y is symmetric , X is orthogonal .
    eq ctxt3 = X is positive-definite , X is symmetric , Y is orthogonal .

endfm 
