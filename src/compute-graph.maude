load simplify.maude

fmod COMPUTE is 
    protecting MATRIX-SIMPLIFY .
    protecting STRING .
    protecting FLOAT .

    sorts Array Statement Assignment Variable Expression .
    subsort Array MatrixSymbol < Variable .
    subsort Variable < Expression .
    subsort Expression Assignment < Statement .

    op _=_ : Variable Expression -> Assignment .
    op copy : Variable -> Variable .

    sort Statements .
    subsort Statement < Statements .
    op _;_ : Statements Statements -> Statements [ctor assoc prec 100] .

    sorts Computation Computations .
    subsort Computation < Computations .
    op _,_ : Computations Computations -> Computations [ctor comm assoc  prec 120   ] .

    op do_where_ : Statements Computations -> Computation [ctor prec 125] .
    op do_ : Statements -> Computation [ctor prec 126] .

    *** A computation to compute MatrixExpr and store it in Variable
    op compute : Variable Situation -> Computation .

    vars X Y Z : MatrixExpr .
    var A B C : Array .
    var S : MatrixSymbol .
    vars alpha beta : Float .
    var Facts : Context .
    var v : Variable .

    *** Some utility functions
    op TRANS : MatrixExpr -> Char . 
    eq TRANS(transpose(X)) = "T" .
    eq TRANS(X) = "N" [owise] . 

    op remove-transpose : MatrixExpr -> MatrixExpr . 
    eq remove-transpose(transpose(X)) = X .
    eq remove-transpose(X) = X [owise] .
    
    op Side : MatrixExpr MatrixExpr Context -> Char .
    ceq Side(X, Y, Facts) = "L" if Facts => X is symmetric .
    ceq Side(X, Y, Facts) = "R" if Facts => Y is symmetric .

    op UPLO : Situation -> Char .
    ceq UPLO(X with Facts) = "U" if Facts => X is upper-triangular .
    ceq UPLO(X with Facts) = "L" if Facts => X is lower-triangular .

    op DIAG : Situation -> Char .
    ceq DIAG(X with Facts) = "U" if Facts => X is unit-triangular .
    eq DIAG(X with Facts)  = "N" [owise] .

    op LD : MatrixExpr -> Nat .
    eq LD(transpose(X)) = rows(X) . 
    eq LD(X) = rows(X) [owise] .

    *** Need to find a better way to generate variables
    ops Ar Br Cr Dr : -> Array .

    eq compute(v, S with Facts ) = do v = S .
endfm

fmod COMPUTE-TEST is 
    protecting COMPUTE .

    ops X Y Z : -> MatrixSymbol .
    eq X = matrix('X, 5 by 5) . 
    eq Y = matrix('Y, 5 by 5) .
    eq Z = matrix('Z, 5 by 5) .
    op v : -> Variable . 
    ops a b : -> Float .

endfm
