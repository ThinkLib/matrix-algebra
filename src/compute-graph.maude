load simplify.maude
load computations.maude 

fmod COMPUTE is 
    protecting MATRIX-SIMPLIFY .
    protecting STRING .
    protecting FLOAT .

    sorts Computation Computations .
    subsort Computation < Computations .
    op _,_ : Computations Computations -> Computations [ctor comm assoc prec 70 id: empty ] .
    op empty : -> Computations . 

    sorts Array Statement Assignment Variable Expression .
    subsort Array < Variable .
    subsort Variable < Expression .
    subsorts Expression Assignment < Statement .
    op load : MatrixSymbol -> Array .

    op _=_ : Variable Expression -> Assignment .
    op copy : Variable -> Variable .

    sort Statements .
    subsort Statement < Statements .
    op _;_ : Statements Statements -> Statements [ctor assoc prec 70 ] .

    op do{_}where{_} : Statements Computations -> Computation [ctor prec 75] .
    op do_ : Statements -> Computation [ctor prec 76] .

    *** A computation to compute MatrixExpr and store it in Variable
    op compute : Variable Situation -> Computation .

    vars X Y Z : MatrixExpr .
    var S : MatrixSymbol .
    var Facts : Context .
    var v : Variable .

    *** Some utility functions
    op TRANS : MatrixExpr -> Char . 
    eq TRANS(transpose(X)) = "T" .
    eq TRANS(X) = "N" [owise] . 

    op remove-transpose : MatrixExpr -> MatrixExpr . 
    eq remove-transpose(transpose(X)) = X .
    eq remove-transpose(X) = X [owise] .
    
    op Side : MatrixExpr MatrixExpr Context -> Char .
    ceq Side(X, Y, Facts) = "L" if Facts => X is symmetric .
    ceq Side(X, Y, Facts) = "R" if Facts => Y is symmetric .

    op UPLO : Situation -> Char .
    ceq UPLO(X with Facts) = "U" if Facts => X is upper-triangular .
    ceq UPLO(X with Facts) = "L" if Facts => X is lower-triangular .

    op DIAG : Situation -> Char .
    ceq DIAG(X with Facts) = "U" if Facts => X is unit-triangular .
    eq DIAG(X with Facts)  = "N" [owise] .

    op LD : MatrixExpr -> Nat .
    eq LD(transpose(X)) = rows(X) . 
    eq LD(X) = rows(X) [owise] .
    
    *** Need to find a better way to generate variables
    ops Ar Br Cr Dr : -> Array .

    eq compute(v, S with Facts ) = (do v = load(S)) .

    var comp : Computation .
    var computations : Computations .
    var statements : Statements .
    op allvalid : Computations -> Bool .
    op valid : Computation -> Bool .
    eq allvalid(empty) = true .
    eq valid(do{statements}where{computations}) = allvalid(computations) .
    eq allvalid(comp, computations) = valid(comp) and allvalid(computations) . 
    eq valid(do v = load(S)) = true .

endfm

fmod COMPUTE-TEST is 
    protecting COMPUTE .

    ops X Y Z : -> MatrixSymbol .
    eq X = matrix('X, 5 by 5) . 
    eq Y = matrix('Y, 5 by 5) .
    eq Z = matrix('Z, 5 by 5) .
    op v : -> Array . 
    ops a b : -> Float .

endfm

---red in COMPUTE-TEST : valid(compute(v, X with no-knowledge)) .
---red in COMPUTE-TEST : valid(compute(v, transpose(X) with no-knowledge)) .
---red in COMPUTE-TEST : allvalid(compute(v, X with no-knowledge) , compute(v, transpose(X) with no-knowledge)) .
